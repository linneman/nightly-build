<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>The Bond Nightly Release System</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Bond</span> <span class="project-version">1.0.6</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="01_README.html"><div class="inner"><span>The Bond Nightly Release System</span></div></a></li><li class="depth-1 "><a href="02_supplementary_documents.html"><div class="inner"><span>Supplementary Documents</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>crossover</span></div></div></li><li class="depth-2"><a href="crossover.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>server</span></div></div></li><li class="depth-2 branch"><a href="server.auth.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>auth</span></div></a></li><li class="depth-2 branch"><a href="server.build-log-handler.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>build-log-handler</span></div></a></li><li class="depth-2 branch"><a href="server.build-task.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>build-task</span></div></a></li><li class="depth-2 branch"><a href="server.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch"><a href="server.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="server.cron.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cron</span></div></a></li><li class="depth-2 branch"><a href="server.crypto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>crypto</span></div></a></li><li class="depth-2 branch"><a href="server.email.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>email</span></div></a></li><li class="depth-2 branch"><a href="server.local-settings.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>local-settings</span></div></a></li><li class="depth-2 branch"><a href="server.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li><li class="depth-2 branch"><a href="server.shell-utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>shell-utils</span></div></a></li><li class="depth-2 branch"><a href="server.tasks.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tasks</span></div></a></li><li class="depth-2"><a href="server.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#the-bond-nightly-release-system" id="the-bond-nightly-release-system"></a>The Bond Nightly Release System</h1>
<p>A Functional Programming Environment for the Automatic Creation of Software Release Candidates</p>
<p><img src="doc/screenshot_status_page.png" /></p>
<h2><a href="#object-why-do-we-need-this" id="object-why-do-we-need-this"></a>Object - Why do we need this?</h2>
<p>When dealing  with complex and long  running software build processes  for multi core network access devices,  ‘industry standard’ continous integration concepts have proven insufficient for  us. One reason for this conclusion  is that a full compilation process  can depending on  the capabilities of used  hardware easily take several hours. In  addition, it can not be predicted  when a build actually shall  be started  in  the majority  of the  cases  simply because  dependencies between  different parts  of the  software are  unknown or  cannot be  correctly mapped by  the source code  management system. This  leads to a  situation where automatic  builds  which are  triggered  by  any  given  change in  source  code repositories in  the period of minuts  mostly fail. Besides, there  is usually a high effort to  take into account for  testing which is very  difficult to fully automate in our  domain.</p>
<p>It therefore  seems to  us to be  much more practicable  to run  fully automated build  and release  processes  at  night. While  this  is  easily possible  with existing solutions,  these have  still major shortcomings.  The main  problem we face is that  typical domain specific progamming languages (DSL)  in use are not really flexible, but still complex and static. By the last point we mean that in example it is usually not possible to  fix problems within the source code or in the  build sequence  without  restarting the  complete build.  That  leads to  a situation  where major  parts of  the software  release process  are still  done manually usually by  a software integrator. As a last  consequence, this results in a  situation where changes to  the source code (commits)  are integrated with significant delay.  Instead of  getting a  complete build  for these  changes at least on a daily  base, it often takes more than a week  until a given changeset is finally integrated.</p>
<p>With this project we try to address these problems. Like typical CI solutions it is based  on the execution  of a sequence of  build steps which  are exclusively remotely executed on  a build host via  ssh. Whenever a build step  fails, it is possible to address the  problem by changing the source code  on that build host and restart the sequence again. The  processing engine for these build sequences is implemented  in Clojure  which is a  highly dynamic  programming environemnt. This allows  to change even  the underlying  implementation of this  CI solution without  restarting within  an interactive  programming environment,  called the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>.  The last point requires of course some  knowledge of Clojure and associated software tools but  also without such specific  knowledge, this tools should  prove to be very useful.</p>
<h2><a href="#requirements" id="requirements"></a>Requirements</h2>
<p>The  present  tool  itself  is  entrily  written  in  the  <a href="http://clojure.org">Clojure  programming language</a> which  requires a Java virtual  machine of version 1.8 or later and some additional libraries for operation.</p>
<p>Furthermore  it can  be exclusively  used on  Unix hosts  since it  envokes some system tools  directly e.g. ‘ssh’,  ‘scp’, ‘cp’, etc. and  thus it is  not ‘100% pure Java’.</p>
<h2><a href="#installation-and-first-start" id="installation-and-first-start"></a>Installation and First Start</h2>
<p>Download the  precompiled binary using  the following command as  illustrated in the following shell command:</p>
<pre><code>wget https://github.com/linneman/nightly-build/releases/download/v1.0.6/bond-1.0.6-standalone.jar
</code></pre>
<p>The nightly build service daemon is started via the following command line:</p>
<pre><code>java -jar bond-1.0.6-standalone.jar
</code></pre>
<p>When the  server is started for  the first time, the  following preference files are initially installed in the user’s home directory:</p>
<pre><code>.nightly-build/local_settings.clj      # server configuration
.nightly-build/key_crt.jks             # Java Key Store with SSL certificates
build-descriptions/sample_config.clj   # sample build configuration
build-descriptions/ltenad_config.clj   # practical application example
</code></pre>
<p>The file  local_settings.clj provides most  of configuration parameters  such as the http(s) and REPL ports to be used.  By default the web server can be reached on port 3000 on localhost.</p>
<p>All build configurations are stored in the directory build-descriptions. When it does  not  exist  already,  it  is created  and  two  sample  configuration  are preinstalled by default. When no error occured, you should be able to access the server on the local host via the following URL:</p>
<p><a href="http://localhost:3000">http://localhost:3000</a></p>
<p>Provided  that the  server  is accessible  under the  hostname  being used,  the following URL should also work:</p>
<p><a href="http://domain-name:3000">http://&lt;domain-name&gt;:3000</a></p>
<p>If  not,   the  domain   name  to   be  used   can  be   changed  in   the  file .nightly-build/local-settings with the parameter <em>http-host</em>.</p>
<p>Immediately after starting the server, an administration URL is displayed on the local console:</p>
<pre><code>______________ Administration Account ______________
Copy and paste the following URL into your brower to
active the administration account:

http://&lt;hostname&gt;:3000/confirm?name=admin&amp;key=iUMXdnWbPzwExRz%2BclC8xA%3D%3D

____________________________________________________
</code></pre>
<p>This  URL  is  used  to  unlock  the administrator  account  and  must  be  used immediately after starting  the server. Via the login button  in the upper right corner  of the  web interface  a new  password should  be assigned  to the  user ‘admin’.</p>
<h2><a href="#compiling-nightly-build" id="compiling-nightly-build"></a>Compiling nightly-build</h2>
<p>You need  the clojure build  tool leinignen  for compilation. Download  the lein script file from Github</p>
<pre><code>$ cd ~/bin
$ wget http://github.com/technomancy/leiningen/raw/stable/bin/lein
$ chmod +x lein
</code></pre>
<p>and type</p>
<pre><code>$ lein self-install
</code></pre>
<p>The following command will generate and stand-alone jar file:</p>
<pre><code>$ lein uberjar
</code></pre>
<p>Refer also to <a href="http://zef.me/2470/building-clojure-projects-with-leiningen">Zef’s Leiningen page</a> for more specific information about build options.</p>
<h2><a href="#usage" id="usage"></a>Usage</h2>
<p>The use of  the web interface is largely self-explanatory.  The radio buttons on the left side can be used to select the respective functions. The most important point  is  the ‘Build  Status’,  in  which the  build  results  for all  release candidates are  displayed in  a comprehensive  list. This  list is  empty during initial start-up.</p>
<p>Using the  menu item  ‘Cron Jobs’,  build processes can  be started  manually or time-controlled.</p>
<p>The menu item  ‘Configurations’ allows to change build  configurations or create new  ones.  However,  for  the  development  of  complicated  build  procedures, the  use  of external  development  tools  is  recommended.  You can  find  more information about this  under the menu item ‘Advanced’ or  in the section <a href="#Build-Configurations">Build Configurations</a> further down in the text.</p>
<h3><a href="#starting-the-first-test-build" id="starting-the-first-test-build"></a>Starting the First Test Build</h3>
<p>In directory build-descriptions the  build configuration ‘sample_config.clj’ was added which can be executed immediately. The only requirement is a key based ssh authentication to the local or any remote build machine. Refer to <a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server">this tutorial</a> for more detail information how to set this up.</p>
<p>The  easiest way  is  to use  the  local host  as a  build  machine. If  ssh-key authentication is  installed correctly, the  following command should  print the contents of the root directory without a password prompt.</p>
<pre><code>ssh localhost "ls /"
</code></pre>
<p>If this is the case, first activate the  cron table via the menu item ‘Cron’. In the table  row ‘create-build-description-sample-1’ select the  entry ‘Start’ via the button ‘Action’. The build is started immediately and displayed in the table ‘Build Status’. There you can get further information like the console output of the build process and stop and restart the build process.</p>
<h3><a href="#setting-up-additional-users" id="setting-up-additional-users"></a>Setting up Additional Users</h3>
<p>New users  can be created  under the menu item  ‘Administration’. Administration rights are required for this. The following roles can be assigned to users:</p>
<table>
<thead>
<tr><th>role    </th><th> allowed actions</th></tr>
</thead>
<tbody>
<tr><td>admin   </td><td> create new users, change build configurations</td></tr>
<tr><td>control </td><td> Starting and stopping build processes, changes to the front table</td></tr>
<tr><td>view    </td><td> new allocation of the own password</td></tr>
</tbody>
</table>
<p>The currently used rights configuration allows  that unlogged users can at least view all build configurations. If this is  not desired, this can be adjusted via the access-method-hash data structure in the server/core.cljs file.</p>
<h3><a href="#build-configuration" id="build-configuration"></a>Build Configuration</h3>
<p>All build configurations are fully  declared within a single configuration file. Three data structures are used:</p>
<ol>
<li>The crontab declares at which times specific builds are started</li>
<li>A build description fully describes a build process. It encapsulates:</li>
<li>A sequence of build step actions which are executed via remote ssh.</li>
</ol>
<p>Refer also to the help page <a href="https://htmlpreview.github.io/?https://github.com/linneman/nightly-build/blob/master/resources/public/creating-build-descriptions.html">Creating Build Descriptions</a> for further information.</p>
<p>Whenever  a  new  build  process  is triggered,  a  new  build-task-sequence  is instantiated. All build-task-sequences  are internally stored within  a hash map using an unique identifier  which consist of the build name and  the time it has been started. It can be later on retrieved and restarted by utility functions illustrated <a href="src/nightly_build/build_task.clj#L476">in the source file build_task.clj</a>. Before we illustrate these underlying processes  in more detail, we will explain the three major configuration structures.</p>
<h4><a href="#the-crontab" id="the-crontab"></a>The Crontab</h4>
<p>What needs to be done at which time is defined by the so called crontab which is based on the corresponding <a href="https://en.wikipedia.org/wiki/Cron">Unix construct</a>. The  crontab  is created  at  startup  or at  any  later  time by  invoking  the function  <a href="src/nightly_build/core.clj#L51">restart-cron-processing</a>  with  using cron build  descriptions defined in  the configuration file. The  data structure cron-build-description is  an array of hash  maps denoted by curly  braces. Each element of  the array  corresponds to  the tigger points  of one  specific build described by  a build description  handler. The  hash map provide  the following key value pairs:</p>
<dl>
  <dt>m</dt>
  <dd>minute to start the build</dd>
  <dt>h</dt>
  <dd>hour to start the build</dd>
  <dt>dom</dt>
  <dd>day of month when to start the build. Use false to start at any day</dd>
  <dt>mon</dt>
  <dd>month when to start the build. Use false to start at any month</dd>
  <dt>dow</dt>
  <dd>day of week when to start the build. Use false to start at any week</dd>
</dl>
<p>In  example  the  following  cron-build-description definition  will  start  the associated build at daily at wo o’clock in the morning:</p>
<pre><code class="language-clojure">(def cron-build-descriptions
  [{:m 0 :h 02 :dom false :mon false :dow false
    :desc create-build-description-mdm9607-bl2_2_0}])
</code></pre>
<p>The entries of the crontab can also be easily edited via the web interface under the menu item ‘Cron Jobs’.</p>
<h4><a href="#the-build-description" id="the-build-description"></a>The Build Description</h4>
<p>The build description is the main data  structure which defines all aspects of a complete build process.  It mainly includes template variables such  as the host where the build  is executed on, directories, repository and  branch names to be used and so on.  Since often similar builds with only  minor differences such as in example different  branches for different hardware releases  are required, we separate the actual build steps from the build description.</p>
<p>Ultimately the build description is created by a dedicated function in the build configuration file which returns a hash map with the concrete configuration. Its most import key value pairs are:</p>
<dl>
  <dt>build-uuid</dt>
  <dd>an unique identifier string describing the build. Usually the combination
      of the build name and the creation date is used.</dd>
  <dt>build-log-filename</dt>
  <dd>log file where all build output is stored on the host which runs the
      nightly build daemon</dd>
  <dt>build-machine</dt>
  <dd>remote build host controlled via ssh described by hostname and port</dd>
  <dt>task-list</dt>
  <dd>the list of concrete tasks which are executed (mostly) via remote ssh
      on the build host. The tasks are executed on after another until
      the execution of one task fails.</dd>
  <dt>terminate</dt>
  <dd>provides one termination task which is executed on the machine which
      is running the nightly build service and an optional finalization
      handler which is in example used to send out a status email. The
      terminate function is always executed.</dd>
</dl>
<h4><a href="#build-steps-and-termination-handler" id="build-steps-and-termination-handler"></a>Build Steps and Termination Handler</h4>
<p>As already mentioned, the task-list and the terminate function are created by a separate function. Refer in example to <a href="resources/build-descriptions/ltenad_config.clj#L85">create-build-steps-ltenad9607</a> for an illustration of the describtion all the steps for a complex build process.</p>
<p>The most important aspect  is the so called task list which is  simply a list of vector with the following structure:</p>
<pre><code class="language-clojure">(list
  [&lt;id1&gt; &lt;commands&gt; &lt;timeout&gt;]
  [&lt;id2&gt; &lt;commands&gt; &lt;timeout&gt;]
  ...)
</code></pre>
<p>Each build steps is described by an  identifier (id), a string of shell commands which are  executed via  remote ssh and  a timeout after  the remote  process is automatically interrupted and considered as having failed.</p>
<p>A key based ssh authentication to remote build machine is a prerequisite. Refer to <a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server">this tutorial</a> for more detail information how to set this up.</p>
<p>The termination handler is excuted always  and allows to provide tasks for clean up, sending  up status information,  etc. In the provided  example we use  it to copy the complete build  log file back to the associated  build directory on the build host and  to send out a  status email indicating whether or  not the build was successful.</p>
<p>Refer also to the help page <a href="https://htmlpreview.github.io/?https://github.com/linneman/nightly-build/blob/master/resources/public/creating-build-descriptions.html">Creating Build Descriptions</a> for further information.</p>
<h2><a href="#interactive-control-of-build-processes-via-the-repl" id="interactive-control-of-build-processes-via-the-repl"></a>Interactive Control of Build Processes via the REPL</h2>
<p>The   <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> allows to modify all aspects of the nightly-build service engine without the need of a  restart which  is one  is its  major benifits.  When started,  the service automatically creates a <a href="https://nrepl.org">nREPL</a>  services which is by default configured  to exclusively  allow local  connections via  port 7888.  For remote connection ssh port forwarding can be used to deal with access credentials.</p>
<p>Besides the mostly used combination of <a href="https://www.gnu.org/software/emacs">Emacs</a> and <a href="https://cider.readthedocs.io">Cider</a>, there are even integrated development environments (IDE’s) for nREPL based development in Clojure. Refer in exjample to <a href="https://cursive-ide.com">Cursive</a> which is based on the IntelliJ IDEA and <a href="http://doc.ccw-ide.org">Counter Clock Wise</a> which is based on Eclipse.</p>
<p>In example  start a new connection  to the nREPL  server on Emacs by  typing M-x cider-connect followed  by entering ‘localhost’  for the  Host and 7888  for the port. The IDE’s  offer similar functionality which is described  in the relevant help files.</p>
<p>Refer to the help page <a href="https://htmlpreview.github.io/?https://github.com/linneman/nightly-build/blob/master/resources/public/connecting-an-external-repl.html">Connecting an external REPL</a> for an  illustration of  various integrated  development environments  and their specific advantages and disadvantages.</p>
<h3><a href="#restarting-and-stopping-processing-of-the-crontable" id="restarting-and-stopping-processing-of-the-crontable"></a>(Re)Starting and Stopping Processing of the Crontable</h3>
<p>Switch the  current name space to  the command line interface  (cli) definitions within  the file  <a href="src/nightly_build/core.clj">core.clj</a>  which can  be done  in Emacs by  typing C-c M-n. The  IDE’s provide corresponding functionality.  As an alternative copy and paste the following line to the REPL window (cider):</p>
<pre><code>(in-ns 'nightly-build.core)
</code></pre>
<p>With the commands</p>
<pre><code>(stop-cron-processing)
(restart-cron-processing)
</code></pre>
<p>The processing  of cron jobs  will be  stopped respectively restarted.  When the build definitions  within the  configuration files have  been changed,  the file shall be re-evaluted in example by the following command before:</p>
<pre><code>(load-file "build-descriptions/&lt;build-configuration&gt;.clj")
</code></pre>
<p>With  the flag  ‘enabled’ specific  cron  jobs can  be deactivated  via the  web interface as well.</p>
<h3><a href="#investigating-running-and-completed-builds" id="investigating-running-and-completed-builds"></a>Investigating Running and Completed Builds</h3>
<p>Switch the current name space to build-tasks and invoke the following commands:</p>
<pre><code>(get-all-build-uuids)
</code></pre>
<p>The function will return nil when no build have been defined (executed yet). For testing and development purposes it is recommended to execute the commands in the comment section of <a href="src/nightly_build/build_task.clj#406">the source file build_task.clj</a>:</p>
<p>In example:</p>
<p>The following lines create a new build sequence:</p>
<pre><code class="language-clojure">(def task-sequence-id (gen-build-task-sequence create-build-description-mdm9607-bl2_2_0
                                               build-log-handler))
</code></pre>
<p>which can be simply started by</p>
<pre><code class="language-clojure">(start-build-task-sequence task-sequence-id)
</code></pre>
<p>The    functions    is-task-sequence-running?,    get-task-sequence-state    and get-last-error allow further retrieval of the  build state. When a build failed, its last failed build step can be restarted at any time by invoking the function start-build-task-sequence again.  All currently running or  terminated tasks are stored in  an internal  hash table  - the tasks  store -  whose contents  can be retrieved via  the function get-all-build-uuids. The  associated task-sequences, build  descriptions and  so  on  can be  retrieved  with  the respective  getter functions.</p>
<h2><a href="#license" id="license"></a>License</h2>
<p>This software stands under the terms of the <a href="http://www.gnu.org/licenses/gpl.html">GNU General Public Licence</a>.</p>
<p>2019, Otto Linnemann</p>
</div></div></div></body></html>