<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Nightly Build Server</title>
    <meta name="author" content="Otto Linnemann">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="img/favicon.ico">
    <link rel="stylesheet" type="text/css" href="css/common.css">

    <link rel="stylesheet" type="text/css" href="css/project.css" />
    <link rel="stylesheet" type="text/css" href="css/auth.css" />
    <link rel="stylesheet" type="text/css" href="css/repl.css" />
    <link rel="stylesheet" type="text/css" href="css/button.css">
    <link rel="stylesheet" type="text/css" href="css/flatbutton.css">
    <link rel="stylesheet" type="text/css" href="css/css3button.css">
    <link rel="stylesheet" type="text/css" href="css/gh-fork-ribbon.css" />
    <link rel="stylesheet" type="text/css" href="css/dialog.css" />
    <link rel="stylesheet" type="text/css" href="css/tab.css" />
    <link rel="stylesheet" type="text/css" href="css/tabbar.css" />
    <link rel="stylesheet" type="text/css" href="css/buildtable.css" />
    <link rel="stylesheet" type="text/css" href="css/build-configurations.css" />
    <link rel="stylesheet" type="text/css" href="css/crontable.css" />
    <link rel="stylesheet" type="text/css" href="css/usertable.css" />
    <link rel="stylesheet" type="text/css" href="css/custombutton.css">
    <link rel="stylesheet" type="text/css" href="css/menu.css">
    <link rel="stylesheet" type="text/css" href="css/menuitem.css">
    <link rel="stylesheet" type="text/css" href="css/menuseparator.css">
    <link rel="stylesheet" type="text/css" href="css/menubutton.css">
    <link rel="stylesheet" type="text/css" href="css/menubar.css">
    <link rel="stylesheet" type="text/css" href="css/prettify.css">
    <link rel="stylesheet" type="text/css" href="css/clojurecode.css">
    <!--[if IE]>
        <link rel="stylesheet" type="text/css" href="mainpanel.css" media="all">
        <![endif]-->
    <!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
  </head>

  <body>

    <div id="header-container" class="sticky">
      <div id="header">
        <div id="header-left">Nightly Build Server</div>
      </div>
    </div>

    <div id="header-separation"></div>

    <div class="content">
      <div id="nightly-build-tab-menu" class="goog-tab-bar goog-tab-bar-start">
        <div id="logo"><img src="img/logo.png" width="120"></div>
        <h3>Help Contents</h3>
        <table>
          <tr><td><a href="clojure-intro.html">Introduction</a></td></tr>
          <tr><td><a href="online-repl.html">The Online REPL</a></td></tr>
          <tr><td><a href="creating-build-descriptions.html">Build Descriptions</a></td></tr>
          <tr><td><a href="connecting-an-external-repl.html">External REPL</a></td></tr>
          <tr><td><a href="doc/api/index.html">API Docs</a></td></tr>
        </table>
      </div>

      <div class="nightly-build-tab-content">
        <div class="nightly-tabpane doc">
          <h2>Introduction to Clojure</h2>

          <h3  id="why_clojure">Why  Clojure?</h3>  <p>The  Bond  Nightly  Release
            Candidate Automation  System is  entirely based  on Clojure,  a powerful
            functional programming  language which  targets mainly the  Java Virtual
            Machine (JVM). Unlike  other solutions of this kind, Bond  does not come
            with a distinctive Domain Specific Language (DSL) for the implementation
            of build sequences, also known as  build pipelines, but instead uses the
            same  programming language  to  implement these.  This allows  increased
            flexibility and  ultimately more  consise formulation of  software build
            processes. Furthermore,  since the implementation of  the control server
            and of  build sequences descriptions are  based on the same  idioms, the
            build runtime system itself can be extended relatively easily.</p>

          <p>Clojure offers numerous other advantages. The most important of these
            in this context is its  REPL based runtime development environment which
            allows to  make changes to the  implementation without the need  to stop
            and recompile  a given  application. The result  is an  extremly compact
            runtime  implementation for  the  build execution  of approximately  500
            lines of code only.</p>

          <p>However, it is  of course necessary to get familiar  with the Clojure
            programming system  at least to some  extent. The purpose of  these help
            pages is  to help newcomers  to get  started with the  build description
            syntax and the basics of Clojure as quickly as possible.</p>

          <p>Please note, however, that this is not a comprehensive description of
            the Clojure programming language and  its development tools. This manual
            is limited  to the minimum  necessary to  understand the concept  of the
            'build descriptions' which are most relevant in this context.</p>

          <p>For further information we recommend the website
            <a href="http://clojure.org">clojure.org</a> as first point of entry.
            For those who prefer a printed manual we recommend the titles
            <a href="https://pragprog.com/book/shcloj3/programming-clojure-third-edition">Programming
              Clojure from Alex Miller, Stuart Halloway and Aaron Bedra</a> for
            an easy start and
            <a href="http://www.joyofclojure.com/">The Joy of Clojure from Stuart Halloway</a>
            for a discussion of more advanced concepts. For a brief introduction
            about the reasoning of the Clojure Programming Language we encourage
            you to listen to the lecture
            <a href="https://www.youtube.com/watch?v=-6BsiVyC1kM">The Value of Values</a>
            from the Creator of Clojure himself, Rich Hickey.</p>

          <h3>First Steps</h3>

          <p>The  infamous hello  world program  in Clojure  is just  one line  of
            code:</p>

          <font size="5"><pre class="prettyprint lang-clj">(println "Hello, World!")</pre></font>

          <p>It is  immediately noticeable that,  in contrast to  most programming
            languages, the opening  parenthesis is placed before  the function name.
            This may  seem strange at  first sight. But  there are good  reasons for
            this notation. It is because Clojure is actually a dialect of Lisp whose
            specific  characteristic is  that all  instructions including  those for
            control flow are  expressed in the form of data  structures. This allows
            to provide  a much simpler  parser and  compiler stage which  is usually
            integrated in the  programming environment itself and  mostly refered to
            as  REPL which  stands for  Read Eval  Print Loop.  Its efficiency  will
            become clear later on.</p>

          <h3>Core Data Structures</h3>

          <h4>Lists</h4>
          <p>The above  instruction which prints  out 'Hello, World!'  is actually
            the most  fundamental list  data structure which  is inherited  from the
            Lisp programming language and enclosed by paranthesis and whose elements
            are separated by  a blank characters. By default the  first element of a
            list  denotes  a  function  name  and the  remaining  elements  are  the
            arguments  which are  passed  to  that function  call.  Lisp stands  for
            nothing else than <i>LISt Processing</i> for this reason.</p>
          <p>If we prevent the function <span  style="font-family:monospace;">println</span>
            in  the  above example  from  being  evaluated,  then  we get  the  list
            structure itself.  This can be  done by  preceding an apostrophe  to the
            list:</p>

          <font size="5"><pre class="prettyprint lang-clj">'(println "Hello, World!")</pre></font>

          <p>But lists can be also expressed explicitly by the list function as in
            example:</p>

          <font size="5"><pre class="prettyprint lang-clj">(list 1 2 "hello")</pre></font>

          <p>Note that the list  elements do not need all to be  of the same type.
            In the above example the first  two elements are of numeric integer type
            while the last  element is a string.  The elements of a  list are single
            connected as depicted in the following illustration:</p>

          <p style="text-align:center;"><img src="img/list.png"></p>

          <p>It  follows that  we  can  efficiently append  elements  only at  the
            beginning of the list because appending an  element to the end of a list
            would require to iterate over all elements. Three fundamental operations
            operation are provided not only for lists but for all data structures in
            Clojure:</p>
          <dl>
            <dt>first</dt>
            <dd>Returns the first element of a list.</dd>

            <dt>rest</dt>
            <dd>Returns a new list with all elements except the first.</dd>

            <dt>conj</dt>
            <dd>Appends an element efficiently. In case of lists the element is appended to the head
              of the list.</dd>
          </dl>

          <p>The following examples illustrate how these operations are used:</p>

          <font size="4"><pre class="prettyprint lang-clj linenums">
              (first (list 1 2 "hello"))   -> 1
              (rest  (list 1 2 "hello"))   -> (2 "hello")
              (conj  (list 1 2 "hello") 0) -> (0 1 2 "hello")</pre></font>

          <p>The build  sequences in Bond are  just Clojure lists or  build steps.
            When a step has been successfully  executed the lists of remaining build
            steps is replaced by the rest of  of the current build step list and the
            processing goes on until all elements have been executed.</p>

          <h4>Vectors</h4>
          <p>Like lists vectors  provide a ordered sequence of  elements. They are
            declared with square brackets. On contrast to lists they allow to access
            efficiently arbitrary elements. Furthermore new elements are appended to
            the end of  a vector. The following examples illustrate  how vectors are
            used:</p>

          <font size="4"><pre class="prettyprint lang-clj linenums">
              [1 2 "hello"]            -> [1 2 "hello"]
              (first [1 2 "hello"])    -> 1
              (rest [1 2 "hello"])     -> (2 "hello")
              (subvec [1 2 "hello"] 1) -> [2 "hello")
              (conj [1 2 "hello"] 0)   -> [1 2 "hello" 0])
              (nth [1 2 "hello"] 1)    -> 2</pre></font>

          <p>Note that  the rest function returns  a list instead of  a vector and
            needs to  iterate over all list  elements. It is recommended  to use the
            function subvector  instead which  operates on vectors  specifically and
            more efficiently. The function conj appends in the given case to the end
            of the vector.</p>
          <p>Lists  are usually  more appropriate  when  all elements  need to  be
            iterated. They provide a stack based,  first in, first out (fifo) access
            characteristics. As already explained functions are just lists where the
            first element  denontes the function name.</p>  <p>Vectors are preferred
            when elements need to be accessed  by index. They provide an queue based
            access  characteristics (lifo).  Vectors  are used  to declare  function
            arguments and local bindins as we will see later on.</p>

          <h4>Maps</h4>
          <p>Maps are collection data types that  map keys to values. The keys and
            the values  can be arbitraty Clojue  data types. Maps are  declared with
            curly brackets as illustrated below:</p>

          <font size="4"><pre class="prettyprint lang-clj linenums">
              (def day-of-week {1 "Monday" 2 "Thuesday" 3 "Wednesday" 4 "Thursday"
              5 "Friday" 6 "Saturday" 7 "Sunday"})
              (day-of-week 1)  -> "Monday"</pre></font>

          <p>In the given  example we define the variable days-of-week  with a map
            where each  day of week  can be  accessed via its  associated index.</p>
          <p>In many cases the consideration is  to use an unique identifier for a
            specific  value  as key.  With  the  so called  <i>keyword</i>,  Clojure
            provides a specific data type for this:</p>

          <font size="4"><pre class="prettyprint lang-clj linenums">
              (def weekday-index {:Monday 1 :Thuesday 2 :Wednesday 3 :Thursday 4
              :Friday 5 :Saturday 6 :Sunday 7})
              (weekday-index :Monday)  ->  1
              (:Monday weekday-index)  ->  1</pre></font>

          <p>Unlike the previously  used strings and integer  key values, keywords
            can be  used like function invocations  as illustrated in line  4 in the
            previous example. So  the third and the fourth line  in this example are
            synomymous</p>
          <p>The data structures can be arbitrarily nested. In example the value in
            vectors can be maps which can include another map and so on. This allows
            to define rather complex data models.</p>
          <p>All data in Clojure is managed  in a <i>functional</i> or, as denoted
            in  Clojure,  <i>persistent</i>  way.  That means  that  by  default  an
            existing  variable is  never  changed  when new  elements  are added  or
            removed.  We  illustrate this  behavior  in  following example  using  a
            map:</p>

          <font size="4"><pre class="prettyprint lang-clj linenums">
              (def rgb-colors-1 {:red [255 0 0] :green [0 255 0]})
              (def rgb-colors-2 (assoc rgb-colors-1 :blue [0 0 255]))
              rgb-colors-1 -> {:red [255 0 0] :green [0 255 0]}
              rgb-colors-2 -> {:red [255 0 0] :green [0 255 0] :blue [0 0 255]}</pre></font>

          <p>Note that the definition in line  3 is not changed by the association
            of  a  new  element  in  line  4.  Instead  the  data  in  the  variable
            <i>rgb-colors-1</i>  is  just  extended  and the  values  for  the  keys
            <i>:red</i>  and   <i>:green</i>  are  re-used   in  <i>rgb-color-2</i>.
            Operations where  the value of a  variable needs to be  acutally changed
            are  required  to  be  expressed   explicitly  as  a  transaction.  Such
            values are  denoted as <i>state</i>  and require special  attention when
            used  in  multi-threaded operations  in  all  programming languages.  On
            contrast, Clojure  uses functional and  thread save data  types wherever
            possible.</p>

          <h3>Functions</h3>
          <p>In  Clojure  functions  are  first-class  and  can  be  passed-to  or
            returned-from  other functions.  In the  following example  we define  a
            simple function which  adds two variables and assign it  to the variable
            add:</p>

          <font size="5"><pre class="prettyprint lang-clj">
              (def add (fn add [a b] (+ a b)))</pre></font>

          <p>The variables of the function are declared inside square brackets. The
            body of the function <span style="font:monospace;">(+ a b)</span> is just
            the invocation of Clojure's build in function <i>+</i>. We could achieve
            a similar effect by:
          </p>

          <font size="5"><pre class="prettyprint lang-clj">
              (def add +)</pre></font>

          <p>Since a clojure  program consists out of a lot  of top level function
            definitions there is short cut which  defines a functions and assigns it
            to the specified identifier with <i>defn</i>:</p>

          <font size="4"><pre class="prettyprint lang-clj linenums">
              (defn add
              "adds the two arguments a and b and returns the result"
              [a b]
              (+ a b))</pre></font>

          <p>In this example we declare a  comment about what the function does in
            the seconds line,  a so called doc string. Doc  strings can be retrieved
            via Clojure's  help system  and are also  used within  API documentation
            generators.</p>

          <h3>Bindings and Destructuring</h3>
          <p>Bindings allow to bind temporary values to local variable. This helps
            to deal with large and nested data structures. We illustrate the concept
            by the following example. Assume  we want to describe the specifications
            of a compilation process with a Clojure hash-map:</p>

          <pre class="prettyprint lang-clj linenums">
            (def my-build-description
            {:build-machine {:host "localhost" :port 22}
            :build-name "project-xyz"
            :build-date (str (java.util.Date.))
            ;; ...
            })</pre>

          <p>In  this very  simplified case  the parameters  of the  build process
            are stored  under the  keys <i>build-machine</i>,  <i>build-name</i> and
            <i>build-date</i> where  <i>build-machine</i> contains  another hash-map
            with  the element  <i>host</i> and  <i>port</i>. It  is very  helpful to
            associate local bindings to these elements e.g. in case they are used in
            mutliple times in a function. The following example illustrates how this
            is done using the Clojure form <i>let</i>:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn print-build-description
            "print build-description tags to stdout"
            [build-description]
            (let [build-machine (:build-machine build-description)
            build-name (:build-name build-description)
            build-date (:build-date build-description)]
            (println build-machine build-name build-date)))</pre>

          <p>The bindings which are created by  let do have local scope only. They
            are  also refered  to as  <i>local bindings</i>  for this  reason. Local
            bindings have precedence  over variable names or bindings  from an upper
            layer as the following example  illustrates where we invoke the function
            <i>print-build-descrition</i>:</p>

          <pre class="prettyprint lang-clj linenums">
            (let [build-name "ABC"]
            (print-build-description my-build-description)) -> {:host localhost, :port 22} project-xyz Sun Feb 23 13:16:54 CET 2020</pre>

          <p>The inner binding of the symbol <i>build-name</i> to the contents of
            hash-map <i>my-build-descriptions</i> overrule the definition of the
            outer contents "ABC" in the above example.</p>

          <p>In the definition of  the function <i>print-build-description</i> the
            extraction of hash map's values for  the given keys is still repetetive.
            Clojure provides  dedicated so called <i>destructuring  mechanism</i> to
            further simplify that as illustrated in the following example:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn print-build-description
            "print build-description tags to stdout"
            [build-description]
            (let [{:keys [build-machine build-name build-date]} build-description]
            (println build-machine build-name build-date))) </pre>

          <p>This version of <i>print-build-description</i> is synonymous with the
            first definition but much shorter. In  the context of the declaration of
            build descriptions <i>descructuring</i> is frequently used.</p>

          <p>The     Bond     framework      provides     an     additional     <a
                                                                                  href="https://clojure.org/reference/macros">macro</a>   which  kind   of
            inverts the destructuring operation. Often it is required to rebuild the
            originally complex  data structure that  has been provided e.g.  via and
            input parameter. Instead of repeating key-value pairs to do so the macro
            <i>hash-args</i> generates a  hash-map where the keys  correspond to the
            given symbols as illustrated in the following example:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn extend-build-description
            "adds another key-value to a given build-description"
            [build-description]
            (let [{:keys [build-machine build-name build-date]} build-description
            {:keys [host port]} build-machine
            version "v1.2.3"]
            (hash-args host port build-name build-date version)))</pre>

          <p>Here  we  destructure the  <i>host</i>  and  <i>port</i> symbols  and
            return a flat hash map with these values:</p>

          <pre class="prettyprint lang-clj">
            (extend-build-description my-build-description) ->

            {:host localhost, :port 22, :build-name project-xyz,
            :build-date Sun Feb 23 13:16:54 CET 2020, :version v1.2.3}</pre>

          <p>This basically  wraps all  the concepts up  which are  typically used
            in  a  so  called  <i>build-description</i>  which  is  the  fundamental
            building block  of the Bond  nightly release  system. It follows  a very
            brief  explanation of  fundamental Clojure's  control structures.  For a
            more  detailed discussion  refer to  further documentation  e.g. the  <a
                                                                                    href="https://clojure.org">Clojure Website</a>.</p>

          <h3>Control Structures</h3>
          <h4>Iterating over Sequences</h4>
          <p>Clojure  offers  numerous  operations   to  iterate  over  sequences.
            Two  of  them we  will  shortly  illustrate  in the  following  example.
            Refer to the <a href="https://clojure.org/reference/sequences">sequences
              documentation  on clojure.org</a>  for more  detailed information.  Most
            frequently we want  to apply an operation to each  element of a sequence
            and store the results in another  sequence. This operation is refered as
            <i>map</i> within Lisp languages:</p>

          <pre class="prettyprint lang-clj">
            (map
            (fn [e] (* e e))
            [0 1 2 3])              ->    (0 1 4 9)</pre>

          <p>Map takes a function and a  sequence as input arguments. The function
            is applied  to each element  of the sequence  to create the  result. The
            expression is often found to be formulated more concisely. The following
            line is synonymous but shorted:</p>

          <pre class="prettyprint lang-clj">
            (map #(* % %) (range 4))  ->    (0 1 4 9)</pre>

          <p>The  second most  important sequence  operation is  <i>reduce</i>. It
            iterates  over  sequence elements  and  accumaltes  the result.  In  the
            following example  we use <i>reduce</i> to  sum up the square  values of
            the previous example:</p>
          <pre class="prettyprint lang-clj">
            (reduce
            (fn [res e] (+ res (* e e)))
            0
            (range 4))              -> 14</pre>

          <p><i>Map</i>  and <i>reduce</i>  can  be applied  to  all of  Clojure's
            sequence data  types. When appropriately  used, they allow  to implement
            many  data processing  functions without  using distinctive  loops in  a
            condensed and expressive way.</p>

          <h4>Conditionals</h4>
          <p>The infamous if-then-else statement is  a function in Clojure as well
            which  returns the  result of  either the  <i>if</i> or  the <i>else</i>
            clause. It  takes up to  three arguments, the condition  expression, the
            <i>if</i> clause and optionally the <i>else</i> clause:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn multiple-of-two
            [x]
            (if (even? x) "yes" "no"))

            (multiple-of-two 17)  ->  no</pre>

          <p>The  above  example is  a  little  bit  odd  and would  be  typically
            formulated as:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn multiple-of-two?
            [x]
            (even? x))</pre>

          <p>The  function  returns  the  directly boolean  result  value  of  the
            operation  <i>even?</i> where  questionmark  indicates  that the  boolean
            getter characteristics of this function.</p>

          <p>There are  cases where  more than one  expression needs  to evaluated
            within an if clause. This usually happens wit the expressions which have
            site effects. An is considered  as <i>purely functional</i> when it does
            not have site  effects. A typical site  effect is I/O as  in depicted in
            the following example:</p>

          <pre class="prettyprint lang-clj linenums">
            (let [logging-enabled true]
            (reduce
            (fn [res e]
            (if logging-enabled
            (do (println "The next element is: " e)
            (println "The current result is: " res)
            (println)))
            (+ res (* e e)))
            0
            (range 4)))</pre>

          <p>This  version  of the  previously  used  <i>recude</i> example  comes
            with  debug  print operations  which  can  be  enabled and  disabled  by
            the  enclosing binding  <i>logging-enabled</i>. When  this evaluates  to
            <i>true</i>, we need  to evaluate more then one expression  to print out
            all the  results. We use  the form  <i>do</i> to group  these operations
            together.  The last  expression  in the  form  <i>do</i> determines  its
            result. Without it Clojure would generate an error because the if clause
            has then more than three arguments.</p>

          <p>The Clojure macro <i>when</i> works similar to the form <i>if</i> but
            takes  just one  condition  and  an arbitary  number  of expressions  as
            arguments  which are  all  evaluated  when the  condition  is true.  The
            following example corresponds  to the previous one  but uses <i>when</i>
            instead of <i>if</i>:</p>

          <pre class="prettyprint lang-clj linenums">
            (let [logging-enabled true]
            (reduce
            (fn [res e]
            (when logging-enabled
            (println "The next element is: " e)
            (println "The current result is: " res)
            (println))
            (+ res (* e e)))
            0
            (range 4)))</pre>

          <h4>Loops</h4>
          <p>Like in other Lisp dialects Clojure implements loops recursively as
            depicted in the following example:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn square-sum
            [res remain]
            (let [e (first remain)]
            (if e
            (recur (+ res (* e e)) (rest remain))
            res)))</pre>

          <p>Here  we define  a function  <i>square</i> which  recursively invokes
            itself until there  are no more elements in  the sequence <i>remain</i>.
            The recurive  invocation is  realized with  the form  <i>recur</i> which
            must be  the last expression in  the enclosing context. It  has the same
            effect  as invoking  <i>square</i> but  releases the  otherwise kept  in
            memory stack. The concept is called <i>tail call optimization</i> and in
            contrast  to other  Lisps needs  to be  expressed in  Clojure explicitly
            with  the  <i>recur</i>  form.</p>

          <p>We are going  to illustrate the difference  between recursive looping
            using tail call optimization and  stack based recursion in the following
            example.  At first  we  invoke the  previous  implementation which  uses
            <i>recur</i>:</p>

          <pre class="prettyprint lang-clj">(square-sum 0 (range 10000)) -> 333283335000</pre>

          <p>When we replace <i>recur</i> by the non optimized call to <i>square</i>
            as illustated here:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn square-sum
            [res remain]
            (let [e (first remain)]
            (if e
            (square (+ res (* e e)) (rest remain))
            res)))</pre>

          <p>we get the following result:</p>

          <pre class="prettyprint lang-clj">
            (square-sum 0 (range 10000))

            -> Execution error (StackOverflowError)</pre>

          <p>because in  this case the  10.000 invocations of  <i>square</i> consumed
            the complete stack of the JVM!</p>

          <p>Because   of   the   recursive  characteristics   of   the   function
            <i>square</i>  we  need  to  always   invoke  it  with  the  exclusively
            internally  used  result  argument  0  and  with  a  sequence  as  input
            arguments. The  macro <i>loop</i>  can be  used to  create an  inner and
            anonymous  version of  the  recursion and  thus allows  to  ommit the  0
            argument  and to  generate the  squence  internally as  depicted in  the
            following:</p>

          <pre class="prettyprint lang-clj linenums">
            (defn square-sum
            [x]
            (loop [res 0
            remain (range (inc x))]
            (let [e (first remain)]
            (if e
            (recur (+ res (* e e)) (rest remain))
            res))))</pre>

          <p>Note  that  the  range  function  does not  include  the  last  value
            so  (range  3)  generates  the  values   0,  1,  2  only.  We  therefore
            increase  the input  argument  <i>x</i> by  one to  include  3 into  the
            square-sum generation. We can now invoke square-sum with a single scalar
            argument:</p>

          <pre class="prettyprint">(square-sum 3) -> 14</pre>

          <p>Note  that this  function can  be formulated  much more  condensed by
            <using i>reduce</i>:</p>

<pre class="prettyprint lang-clj linenums">
  (defn square-sum
  [x]
  (reduce
  (fn [res e] (+ res (* e e)))
  (range (inc x))))</pre>

<p>The initial value  for the accumulator has been ommited  in this example.
  Refer to the
  <a href="https://clojuredocs.org/clojure.core/reduce">documentation about
    reduce</a>  for  further   exaplanation.</p>  <p>As  already  indicated
  looping can  be replaced by  appropriate sequence operations  which are
  usually more  condensed and expressive.  But cases exist where  the low
  level recursive implementation might still be more appropriate.</p>

<h3>What is left out?</h3>
<p>Concratulations!  If  you  could  follow  these  examples,  then  you
  have understood  the most  important aspects  of Clojure  and functional
  programming in general already. However, there are several aspects which
  we could not discussed in this minimalist introduction. These are:</p>

<ul>
  <li>Dealing with Concurrency</li>
  <li>Exception Handling</li>
  <li>Namespaces</li>
  <li>Lazy Evaluation</li>
  <li>Macros</li>
  <li>Working with Java</li>
  <li>The Clojure Build System</li>
  <li>Clojurescript to reach the Browser</li>
</ul>

<p>We   hope  that   we   could   rise  your   interest   and  you   are
  encouraged  to  continue  your  journey   to  get  familiar  with  these
  as  well.   We  already  gave  hints   where  to  go  next   in  the  <a
                                                                          href="#why_clojure">beginning of this page.</a>Have a good start
  and a lot of fun with functional programming!</p>

</div>
</div>
</div>

    <script src="prettify.js"></script>
    <script src="lang-clj.js"></script>
    <script>
      window.onload = (function(){ prettyPrint(); });
    </script>

  </body>
</html>
